#!/usr/bin/env bash
#
# Pre-commit hook for Omnia
# Runs fast, developer-friendly checks on changed code only
#
# To skip this hook, include "[skip-pre-commit]" in your commit message
#
# Installation:
#   ln -sf ../../hack/pre-commit .git/hooks/pre-commit
#

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}ℹ ${NC}$1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_header() {
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
}

# Check if commit message contains skip flag
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    if grep -q "\[skip-pre-commit\]" "$COMMIT_MSG_FILE"; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
fi

# Also check the commit message passed via -m flag
for arg in "$@"; do
    if [[ "$arg" == *"[skip-pre-commit]"* ]]; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
done

print_header "Pre-Commit Checks"
print_info "Running fast checks on changed code only..."

# Track overall status
CHECKS_FAILED=0

# Get the repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Check for staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -z "$STAGED_GO_FILES" ]; then
    print_info "No Go files staged for commit. Skipping checks."
    exit 0
fi

print_info "Found $(echo "$STAGED_GO_FILES" | wc -l | tr -d ' ') Go file(s) to check"

#
# 1. Format check
#
print_header "Checking Formatting"

UNFORMATTED=$(gofmt -l $STAGED_GO_FILES 2>&1 || true)
if [ -n "$UNFORMATTED" ]; then
    print_error "The following files need formatting:"
    for file in $UNFORMATTED; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make fmt' to fix formatting"
    CHECKS_FAILED=1
else
    print_success "All files properly formatted"
fi

#
# 2. Vet check
#
print_header "Running go vet"

if go vet ./... 2>&1; then
    print_success "go vet passed"
else
    print_error "go vet found issues"
    CHECKS_FAILED=1
fi

#
# 3. Lint changed files only
#
print_header "Linting Changed Files"

# Check if golangci-lint is installed
if ! command -v golangci-lint &> /dev/null; then
    print_warning "golangci-lint is not installed"
    echo "  Install with: brew install golangci-lint"
    echo "  Or visit: https://golangci-lint.run/usage/install/"
    print_info "Skipping lint check..."
else
    # Use --new-from-rev=HEAD to only check changes
    if golangci-lint run --new-from-rev=HEAD --timeout=3m ./... 2>&1; then
        print_success "Linting passed"
    else
        print_error "Linting failed"
        CHECKS_FAILED=1
    fi
fi

#
# 4. Build check
#
print_header "Building"

if go build ./... 2>&1; then
    print_success "Build successful"
else
    print_error "Build failed"
    CHECKS_FAILED=1
fi

#
# 5. Run tests with coverage
#
print_header "Running Tests with Coverage"

COVERAGE_THRESHOLD=80

# Run tests with coverage
TEST_OUTPUT=$(go test -short -timeout 120s -coverprofile=coverage.out ./... 2>&1)
TEST_EXIT_CODE=$?

if [ $TEST_EXIT_CODE -ne 0 ]; then
    if echo "$TEST_OUTPUT" | grep -q "FAIL"; then
        print_error "Tests failed"
        echo "$TEST_OUTPUT" | grep "FAIL"
        CHECKS_FAILED=1
    else
        print_success "Tests passed (some packages have no tests)"
    fi
else
    print_success "Tests passed"
fi

# Check total coverage (SonarCloud checks new code coverage, not function-level)
if [ -f coverage.out ]; then
    print_header "Checking Coverage (threshold: ${COVERAGE_THRESHOLD}%)"

    # Get total coverage percentage
    TOTAL_COVERAGE=$(go tool cover -func=coverage.out 2>/dev/null | grep "^total:" | awk '{print $NF}' | tr -d '%')

    if [ -z "$TOTAL_COVERAGE" ]; then
        print_warning "Could not determine coverage"
    else
        COVERAGE_INT=${TOTAL_COVERAGE%.*}
        print_info "Total coverage: ${TOTAL_COVERAGE}%"

        # Note: We don't fail on total coverage because:
        # 1. Generated code (kubebuilder scaffolding) lowers the average
        # 2. SonarCloud checks coverage on NEW code only, not total
        # 3. Function-level 80% is too strict for controller reconciliation loops
        #
        # SonarCloud quality gate is the authoritative coverage check.
        # This is informational only.
        if [ "$COVERAGE_INT" -lt 50 ]; then
            print_warning "Coverage is below 50% - consider adding more tests"
        else
            print_success "Coverage check passed (SonarCloud enforces 80% on new code)"
        fi
    fi

    rm -f coverage.out
fi

#
# 6. Generate manifests check (kubebuilder specific)
#
print_header "Checking Generated Manifests"

# Run generate and check for changes
make generate manifests 2>/dev/null

MANIFEST_CHANGES=$(git diff --name-only config/ api/ 2>/dev/null || true)
if [ -n "$MANIFEST_CHANGES" ]; then
    print_error "Generated manifests are out of date:"
    for file in $MANIFEST_CHANGES; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make generate manifests' and commit the changes"
    CHECKS_FAILED=1
else
    print_success "Generated manifests are up to date"
fi

#
# Summary
#
print_header "Summary"

if [ $CHECKS_FAILED -eq 0 ]; then
    print_success "All pre-commit checks passed!"
    echo ""
    print_info "Proceeding with commit..."
    exit 0
else
    echo ""
    print_error "Pre-commit checks failed!"
    echo ""
    print_info "Options:"
    echo "  1. Fix the issues above and try again"
    echo "  2. Run 'make test' to see detailed test output"
    echo "  3. Use [skip-pre-commit] in commit message to bypass (not recommended)"
    echo ""
    exit 1
fi
