#!/usr/bin/env bash
#
# Pre-commit hook for Omnia
# Runs fast, developer-friendly checks on changed code only
#
# To skip this hook, include "[skip-pre-commit]" in your commit message
#
# Installation:
#   ln -sf ../../hack/pre-commit .git/hooks/pre-commit
#

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}ℹ ${NC}$1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_header() {
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
}

# Check if commit message contains skip flag
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    if grep -q "\[skip-pre-commit\]" "$COMMIT_MSG_FILE"; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
fi

# Also check the commit message passed via -m flag
for arg in "$@"; do
    if [[ "$arg" == *"[skip-pre-commit]"* ]]; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
done

print_header "Pre-Commit Checks"
print_info "Running fast checks on changed code only..."

# Track overall status
CHECKS_FAILED=0

# Get the repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Check for staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

# Check for staged dashboard files (TypeScript/JavaScript)
STAGED_DASHBOARD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '^dashboard/.*\.\(ts\|tsx\|js\|jsx\)$' || true)

#
# Dashboard (TypeScript) Checks
#
if [ -n "$STAGED_DASHBOARD_FILES" ]; then
    print_info "Found $(echo "$STAGED_DASHBOARD_FILES" | wc -l | tr -d ' ') dashboard file(s) to check"

    # Check if npm is available
    if ! command -v npm &> /dev/null; then
        print_warning "npm is not installed, skipping dashboard checks"
    else
        # Check if node_modules exists
        if [ ! -d "$REPO_ROOT/dashboard/node_modules" ]; then
            print_info "Installing dashboard dependencies..."
            (cd "$REPO_ROOT/dashboard" && npm ci --silent)
        fi

        print_header "Dashboard: ESLint"
        if (cd "$REPO_ROOT/dashboard" && npm run lint --silent 2>&1); then
            print_success "ESLint passed"
        else
            print_error "ESLint found issues"
            CHECKS_FAILED=1
        fi

        print_header "Dashboard: TypeScript"
        if (cd "$REPO_ROOT/dashboard" && npm run typecheck --silent 2>&1); then
            print_success "TypeScript check passed"
        else
            print_error "TypeScript check failed"
            CHECKS_FAILED=1
        fi
    fi
fi

# Skip Go checks if no Go files staged
if [ -z "$STAGED_GO_FILES" ]; then
    if [ -z "$STAGED_DASHBOARD_FILES" ]; then
        print_info "No Go or dashboard files staged for commit. Skipping checks."
        exit 0
    fi
    # Dashboard checks ran above, skip to summary
    print_header "Summary"
    if [ $CHECKS_FAILED -eq 0 ]; then
        print_success "All pre-commit checks passed!"
        echo ""
        print_info "Proceeding with commit..."
        exit 0
    else
        echo ""
        print_error "Pre-commit checks failed!"
        echo ""
        print_info "Options:"
        echo "  1. Fix the issues above and try again"
        echo "  2. Use [skip-pre-commit] in commit message to bypass (not recommended)"
        echo ""
        exit 1
    fi
fi

print_info "Found $(echo "$STAGED_GO_FILES" | wc -l | tr -d ' ') Go file(s) to check"

#
# 1. Format check
#
print_header "Checking Formatting"

UNFORMATTED=$(gofmt -l $STAGED_GO_FILES 2>&1 || true)
if [ -n "$UNFORMATTED" ]; then
    print_error "The following files need formatting:"
    for file in $UNFORMATTED; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make fmt' to fix formatting"
    CHECKS_FAILED=1
else
    print_success "All files properly formatted"
fi

#
# 2. Vet check
#
print_header "Running go vet"

if go vet ./... 2>&1; then
    print_success "go vet passed"
else
    print_error "go vet found issues"
    CHECKS_FAILED=1
fi

#
# 3. Lint changed files only
#
print_header "Linting Changed Files"

# Check if golangci-lint is installed
if ! command -v golangci-lint &> /dev/null; then
    print_warning "golangci-lint is not installed"
    echo "  Install with: brew install golangci-lint"
    echo "  Or visit: https://golangci-lint.run/usage/install/"
    print_info "Skipping lint check..."
else
    # Use --new-from-rev=HEAD to only check changes
    if golangci-lint run --new-from-rev=HEAD --timeout=3m ./... 2>&1; then
        print_success "Linting passed"
    else
        print_error "Linting failed"
        CHECKS_FAILED=1
    fi
fi

#
# 4. Build check
#
print_header "Building"

if go build ./... 2>&1; then
    print_success "Build successful"
else
    print_error "Build failed"
    CHECKS_FAILED=1
fi

#
# 5. Run tests with coverage
#
print_header "Running Tests with Coverage"

# Run tests with coverage
TEST_OUTPUT=$(go test -short -timeout 120s -coverprofile=coverage.out ./... 2>&1)
TEST_EXIT_CODE=$?

if [ $TEST_EXIT_CODE -ne 0 ]; then
    if echo "$TEST_OUTPUT" | grep -q "FAIL"; then
        print_error "Tests failed"
        echo "$TEST_OUTPUT" | grep "FAIL"
        CHECKS_FAILED=1
    else
        print_success "Tests passed (some packages have no tests)"
    fi
else
    print_success "Tests passed"
fi

#
# 5b. Check coverage on changed files only
#
if [ -f coverage.out ]; then
    print_header "Checking Coverage on Changed Files"

    COVERAGE_THRESHOLD=80.0
    COVERAGE_FAILED=0
    COVERAGE_RESULTS=()

    # Check each staged Go file (excluding test files and entry points)
    for file in $STAGED_GO_FILES; do
        # Skip test files
        if [[ "$file" == *_test.go ]]; then
            continue
        fi

        # Skip cmd entry points (main.go files are hard to test)
        if [[ "$file" == cmd/* ]]; then
            continue
        fi

        # Skip internal/runtime (requires local PromptKit dependency, not published yet)
        if [[ "$file" == internal/runtime/* ]]; then
            continue
        fi

        # Skip generated files (kubebuilder)
        if [[ "$file" == *zz_generated*.go ]] || [[ "$file" == api/*/groupversion_info.go ]]; then
            continue
        fi

        # Skip generated protobuf files
        if [[ "$file" == *.pb.go ]] || [[ "$file" == *_grpc.pb.go ]]; then
            continue
        fi

        # Skip E2E test utilities
        if [[ "$file" == test/* ]]; then
            continue
        fi

        # Calculate ACTUAL statement coverage from raw coverage.out
        # Format: file:startLine.startCol,endLine.endCol numStatements count
        # count > 0 means covered, count = 0 means not covered
        FILE_COV_PERCENT=$(grep "/$file:" coverage.out 2>/dev/null | awk -F'[ ]' '
        {
            # Last two fields: numStatements count
            # Split on space, get the numeric fields
            n = split($0, parts, " ")
            if (n >= 2) {
                count = parts[n]      # coverage count (0 = not covered, 1+ = covered)
                stmts = parts[n-1]    # number of statements in this block
                if (stmts ~ /^[0-9]+$/ && count ~ /^[0-9]+$/) {
                    total_stmts += stmts
                    if (count > 0) {
                        covered_stmts += stmts
                    }
                }
            }
        }
        END {
            if (total_stmts > 0) {
                printf "%.1f", (covered_stmts / total_stmts) * 100
            }
        }')

        if [ -n "$FILE_COV_PERCENT" ]; then
            # Check if coverage meets threshold
            COV_OK=$(echo "$FILE_COV_PERCENT $COVERAGE_THRESHOLD" | awk '{if ($1 >= $2) print "1"; else print "0"}')

            if [ "$COV_OK" = "1" ]; then
                COVERAGE_RESULTS+=("✓ $file: ${FILE_COV_PERCENT}%")
            else
                COVERAGE_RESULTS+=("✗ $file: ${FILE_COV_PERCENT}% (below ${COVERAGE_THRESHOLD}%)")
                COVERAGE_FAILED=1
            fi
        else
            # No coverage data for this file - check if it has any executable code
            # Files with only type definitions won't have coverage data
            HAS_FUNCS=$(grep -l "^func " "$REPO_ROOT/$file" 2>/dev/null || true)
            if [ -n "$HAS_FUNCS" ]; then
                COVERAGE_RESULTS+=("✗ $file: 0.0% (no coverage data)")
                COVERAGE_FAILED=1
            else
                COVERAGE_RESULTS+=("○ $file: N/A (no executable code)")
            fi
        fi
    done

    # Print results
    if [ ${#COVERAGE_RESULTS[@]} -eq 0 ]; then
        print_info "No non-test Go files to check (all changes in test/cmd files)"
    else
        for result in "${COVERAGE_RESULTS[@]}"; do
            echo "  $result"
        done

        echo ""
        if [ $COVERAGE_FAILED -eq 1 ]; then
            print_error "Some files have insufficient test coverage (threshold: ${COVERAGE_THRESHOLD}%)"
            print_info "Add tests for the uncovered code"
            CHECKS_FAILED=1
        else
            print_success "All changed files meet coverage threshold (≥${COVERAGE_THRESHOLD}%)"
        fi
    fi

    # Show overall summary
    echo ""
    TOTAL_COVERAGE=$(go tool cover -func=coverage.out | tail -1 | grep -oE '[0-9]+\.[0-9]+%')
    print_info "Overall project coverage: $TOTAL_COVERAGE"

    rm -f coverage.out
fi

#
# 6. Generate manifests check (kubebuilder specific)
#
print_header "Checking Generated Manifests"

# Run generate and check for changes
make generate manifests 2>/dev/null

MANIFEST_CHANGES=$(git diff --name-only config/ api/ 2>/dev/null || true)
if [ -n "$MANIFEST_CHANGES" ]; then
    print_error "Generated manifests are out of date:"
    for file in $MANIFEST_CHANGES; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make generate manifests' and commit the changes"
    CHECKS_FAILED=1
else
    print_success "Generated manifests are up to date"
fi

#
# Summary
#
print_header "Summary"

if [ $CHECKS_FAILED -eq 0 ]; then
    print_success "All pre-commit checks passed!"
    echo ""
    print_info "Proceeding with commit..."
    exit 0
else
    echo ""
    print_error "Pre-commit checks failed!"
    echo ""
    print_info "Options:"
    echo "  1. Fix the issues above and try again"
    echo "  2. Run 'make test' to see detailed test output"
    echo "  3. Use [skip-pre-commit] in commit message to bypass (not recommended)"
    echo ""
    exit 1
fi
