#!/usr/bin/env bash
#
# Pre-commit hook for Omnia
# Runs fast, developer-friendly checks on changed code only
#
# To skip this hook, include "[skip-pre-commit]" in your commit message
#
# Installation:
#   ln -sf ../../hack/pre-commit .git/hooks/pre-commit
#

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}ℹ ${NC}$1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_header() {
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
}

# Check if commit message contains skip flag
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    if grep -q "\[skip-pre-commit\]" "$COMMIT_MSG_FILE"; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
fi

# Also check the commit message passed via -m flag
for arg in "$@"; do
    if [[ "$arg" == *"[skip-pre-commit]"* ]]; then
        print_warning "Skipping pre-commit checks (found [skip-pre-commit] in commit message)"
        exit 0
    fi
done

print_header "Pre-Commit Checks"
print_info "Running fast checks on changed code only..."

# Track overall status
CHECKS_FAILED=0

# Get the repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Check for staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

# Check for staged dashboard files (TypeScript/JavaScript)
STAGED_DASHBOARD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '^dashboard/.*\.\(ts\|tsx\|js\|jsx\)$' || true)

#
# Dashboard (TypeScript) Checks
#
if [ -n "$STAGED_DASHBOARD_FILES" ]; then
    print_info "Found $(echo "$STAGED_DASHBOARD_FILES" | wc -l | tr -d ' ') dashboard file(s) to check"

    # Check if npm is available
    if ! command -v npm &> /dev/null; then
        print_warning "npm is not installed, skipping dashboard checks"
    else
        # Check if node_modules exists
        if [ ! -d "$REPO_ROOT/dashboard/node_modules" ]; then
            print_info "Installing dashboard dependencies..."
            (cd "$REPO_ROOT/dashboard" && npm ci --silent)
        fi

        print_header "Dashboard: ESLint"
        if (cd "$REPO_ROOT/dashboard" && npm run lint --silent 2>&1); then
            print_success "ESLint passed"
        else
            print_error "ESLint found issues"
            CHECKS_FAILED=1
        fi

        print_header "Dashboard: TypeScript"
        if (cd "$REPO_ROOT/dashboard" && npm run typecheck --silent 2>&1); then
            print_success "TypeScript check passed"
        else
            print_error "TypeScript check failed"
            CHECKS_FAILED=1
        fi

        print_header "Dashboard: Tests with Coverage"
        # Run tests with coverage - Vitest enforces thresholds in vitest.config.ts
        # Thresholds: 80% for statements, branches, functions, and lines
        # NOTE: NODE_OPTIONS increases memory for coverage report generation
        DASHBOARD_TEST_OUTPUT=$(cd "$REPO_ROOT/dashboard" && NODE_OPTIONS="--max-old-space-size=4096" npm run test:coverage 2>&1)
        DASHBOARD_TEST_EXIT=$?

        # Check for coverage threshold failures (Vitest outputs "ERROR: Coverage for X does not meet threshold")
        if echo "$DASHBOARD_TEST_OUTPUT" | grep -q "ERROR: Coverage for"; then
            print_error "Dashboard coverage below threshold (80%)"
            echo "$DASHBOARD_TEST_OUTPUT" | grep -E "ERROR: Coverage for" | head -10
            CHECKS_FAILED=1
        elif echo "$DASHBOARD_TEST_OUTPUT" | grep -q "FAIL.*test"; then
            # Actual test failures
            print_error "Dashboard tests failed"
            echo "$DASHBOARD_TEST_OUTPUT" | grep -E "(FAIL|Error:|✕)" | head -20
            CHECKS_FAILED=1
        elif [ $DASHBOARD_TEST_EXIT -ne 0 ] && ! echo "$DASHBOARD_TEST_OUTPUT" | grep -qE "Test Files.*passed"; then
            # Non-zero exit but no passed tests shown - real failure
            print_error "Dashboard tests failed"
            echo "$DASHBOARD_TEST_OUTPUT" | grep -E "(FAIL|Error:|✕)" | head -20
            CHECKS_FAILED=1
        else
            # Extract coverage from Vitest output (format: "All files  |  XX.XX |  XX.XX |  XX.XX |  XX.XX")
            DASHBOARD_COVERAGE=$(echo "$DASHBOARD_TEST_OUTPUT" | grep "All files" | awk -F'|' '{gsub(/[^0-9.]/, "", $2); print $2}')
            if [ -n "$DASHBOARD_COVERAGE" ]; then
                print_success "Dashboard tests passed (coverage: ${DASHBOARD_COVERAGE}%)"
            else
                print_success "Dashboard tests passed"
            fi
        fi

        # Check per-file coverage on staged files (like SonarCloud does)
        COVERAGE_JSON="$REPO_ROOT/dashboard/coverage/coverage-final.json"
        if [ -f "$COVERAGE_JSON" ]; then
            print_header "Dashboard: Per-File Coverage Check"

            COVERAGE_THRESHOLD=80.0
            DASHBOARD_COVERAGE_FAILED=0
            DASHBOARD_COVERAGE_RESULTS=()

            # Check each staged dashboard file (excluding test files and excluded paths)
            for file in $STAGED_DASHBOARD_FILES; do
                # Get just the path relative to dashboard/
                REL_FILE="${file#dashboard/}"

                # Skip test files
                if [[ "$REL_FILE" == *.test.ts ]] || [[ "$REL_FILE" == *.test.tsx ]]; then
                    continue
                fi

                # Skip type definitions
                if [[ "$REL_FILE" == *.d.ts ]]; then
                    continue
                fi

                # Skip index files (re-exports)
                if [[ "$REL_FILE" == */index.ts ]] || [[ "$REL_FILE" == */index.tsx ]]; then
                    continue
                fi

                # Skip excluded paths (matching vitest.config.ts exclusions)
                # Only exclude files that truly cannot be unit tested
                if [[ "$REL_FILE" == src/test/* ]] || \
                   [[ "$REL_FILE" == src/types/generated/* ]] || \
                   [[ "$REL_FILE" == src/types/* ]] || \
                   [[ "$REL_FILE" == src/components/ui/* ]] || \
                   [[ "$REL_FILE" == src/components/agents/* ]] || \
                   [[ "$REL_FILE" == src/components/arena/project-editor.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/file-tree.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/editor-tabs.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/yaml-editor.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/lsp-yaml-editor.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/dev-console-panel.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/job-logs-tab.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/job-results-tab.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/run-dropdown.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/quick-run-dialog.tsx ]] || \
                   [[ "$REL_FILE" == src/components/arena/validation-results-dialog.tsx ]] || \
                   [[ "$REL_FILE" == src/lib/lsp/* ]] || \
                   [[ "$REL_FILE" == src/lib/stubs/* ]] || \
                   [[ "$REL_FILE" == src/components/console/* ]] || \
                   [[ "$REL_FILE" == src/components/cost/* ]] || \
                   [[ "$REL_FILE" == src/components/credentials/* ]] || \
                   [[ "$REL_FILE" == src/components/dashboard/* ]] || \
                   [[ "$REL_FILE" == src/components/layout/* ]] || \
                   [[ "$REL_FILE" == src/components/logs/* ]] || \
                   [[ "$REL_FILE" == src/components/topology/* ]] || \
                   [[ "$REL_FILE" == src/lib/proto/* ]] || \
                   [[ "$REL_FILE" == src/app/layout.tsx ]] || \
                   [[ "$REL_FILE" == src/app/page.tsx ]] || \
                   [[ "$REL_FILE" == src/app/*/layout.tsx ]] || \
                   [[ "$REL_FILE" == src/app/*/page.tsx ]] || \
                   [[ "$REL_FILE" == src/app/**/layout.tsx ]] || \
                   [[ "$REL_FILE" == src/app/**/page.tsx ]] || \
                   [[ "$REL_FILE" == src/app/api/auth/* ]] || \
                   [[ "$REL_FILE" == src/app/api/prometheus/* ]] || \
                   [[ "$REL_FILE" == src/app/api/license/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/agents/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/costs/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/promptpacks/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/providers/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/toolregistries/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/stats/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/arena/projects/* ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/\[name\]/route.ts ]] || \
                   [[ "$REL_FILE" == src/app/api/workspaces/route.ts ]] || \
                   [[ "$REL_FILE" == src/app/api/providers/* ]] || \
                   [[ "$REL_FILE" == src/app/api/config/* ]] || \
                   [[ "$REL_FILE" == src/app/api/health/* ]] || \
                   [[ "$REL_FILE" == src/app/api/settings/* ]] || \
                   [[ "$REL_FILE" == src/middleware.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/live-service.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/operator-service.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/prometheus-service.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/workspace-api-service.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/mock-service.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/types.ts ]] || \
                   [[ "$REL_FILE" == src/lib/data/provider.tsx ]] || \
                   [[ "$REL_FILE" == src/lib/k8s/token-fetcher.ts ]] || \
                   [[ "$REL_FILE" == src/lib/k8s/workspace-k8s-client-factory.ts ]] || \
                   [[ "$REL_FILE" == src/hooks/use-dev-console.ts ]] || \
                   [[ "$REL_FILE" == src/hooks/use-job-logs-stream.ts ]] || \
                   [[ "$REL_FILE" == src/lib/image-processor.ts ]] || \
                   [[ "$REL_FILE" == src/lib/mock-data.ts ]] || \
                   [[ "$REL_FILE" == src/lib/auth/types.ts ]] || \
                   [[ "$REL_FILE" == server.js ]]; then
                    continue
                fi

                # Calculate coverage from JSON using node
                FILE_COV_PERCENT=$(node -e "
                    const fs = require('fs');
                    const coverage = JSON.parse(fs.readFileSync('$COVERAGE_JSON', 'utf8'));
                    const filePath = '$REPO_ROOT/dashboard/$REL_FILE';
                    const data = coverage[filePath];
                    if (data) {
                        const statements = Object.keys(data.statementMap).length;
                        const covered = Object.values(data.s).filter(c => c > 0).length;
                        const pct = statements > 0 ? (covered / statements * 100) : 100;
                        console.log(pct.toFixed(1));
                    }
                " 2>/dev/null)

                if [ -n "$FILE_COV_PERCENT" ]; then
                    # Check if coverage meets threshold
                    COV_OK=$(echo "$FILE_COV_PERCENT $COVERAGE_THRESHOLD" | awk '{if ($1 >= $2) print "1"; else print "0"}')

                    if [ "$COV_OK" = "1" ]; then
                        DASHBOARD_COVERAGE_RESULTS+=("✓ $REL_FILE: ${FILE_COV_PERCENT}%")
                    else
                        DASHBOARD_COVERAGE_RESULTS+=("✗ $REL_FILE: ${FILE_COV_PERCENT}% (below ${COVERAGE_THRESHOLD}%)")
                        DASHBOARD_COVERAGE_FAILED=1
                    fi
                else
                    # No coverage data - file might have only types/interfaces
                    # Check if file has any functions/components
                    HAS_CODE=$(grep -E "(export (function|const|class)|^function )" "$REPO_ROOT/$file" 2>/dev/null | head -1 || true)
                    if [ -n "$HAS_CODE" ]; then
                        DASHBOARD_COVERAGE_RESULTS+=("✗ $REL_FILE: 0.0% (no coverage data)")
                        DASHBOARD_COVERAGE_FAILED=1
                    else
                        DASHBOARD_COVERAGE_RESULTS+=("○ $REL_FILE: N/A (types only)")
                    fi
                fi
            done

            # Print results
            if [ ${#DASHBOARD_COVERAGE_RESULTS[@]} -eq 0 ]; then
                print_info "No non-test dashboard files to check"
            else
                for result in "${DASHBOARD_COVERAGE_RESULTS[@]}"; do
                    echo "  $result"
                done

                echo ""
                if [ $DASHBOARD_COVERAGE_FAILED -eq 1 ]; then
                    print_error "Some dashboard files have insufficient test coverage (threshold: ${COVERAGE_THRESHOLD}%)"
                    print_info "Add tests for the uncovered code (SonarCloud will fail the PR)"
                    CHECKS_FAILED=1
                else
                    print_success "All staged dashboard files meet coverage threshold (≥${COVERAGE_THRESHOLD}%)"
                fi
            fi
        fi
    fi
fi

# Skip Go checks if no Go files staged
if [ -z "$STAGED_GO_FILES" ]; then
    if [ -z "$STAGED_DASHBOARD_FILES" ]; then
        print_info "No Go or dashboard files staged for commit. Skipping checks."
        exit 0
    fi
    # Dashboard checks ran above, skip to summary
    print_header "Summary"
    if [ $CHECKS_FAILED -eq 0 ]; then
        print_success "All pre-commit checks passed!"
        echo ""
        print_info "Proceeding with commit..."
        exit 0
    else
        echo ""
        print_error "Pre-commit checks failed!"
        echo ""
        print_info "Options:"
        echo "  1. Fix the issues above and try again"
        echo "  2. Use [skip-pre-commit] in commit message to bypass (not recommended)"
        echo ""
        exit 1
    fi
fi

print_info "Found $(echo "$STAGED_GO_FILES" | wc -l | tr -d ' ') Go file(s) to check"

#
# 1. Format check
#
print_header "Checking Formatting"

UNFORMATTED=$(gofmt -l $STAGED_GO_FILES 2>&1 || true)
if [ -n "$UNFORMATTED" ]; then
    print_error "The following files need formatting:"
    for file in $UNFORMATTED; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make fmt' to fix formatting"
    CHECKS_FAILED=1
else
    print_success "All files properly formatted"
fi

#
# 2. Vet check
#
print_header "Running go vet"

if go vet ./... 2>&1; then
    print_success "go vet passed"
else
    print_error "go vet found issues"
    CHECKS_FAILED=1
fi

#
# 3. Lint changed files only
#
print_header "Linting Changed Files"

# Check if golangci-lint is installed
if ! command -v golangci-lint &> /dev/null; then
    print_warning "golangci-lint is not installed"
    echo "  Install with: brew install golangci-lint"
    echo "  Or visit: https://golangci-lint.run/usage/install/"
    print_info "Skipping lint check..."
else
    # Use --new-from-rev=HEAD to only check changes
    if golangci-lint run --new-from-rev=HEAD --timeout=3m ./... 2>&1; then
        print_success "Linting passed"
    else
        print_error "Linting failed"
        CHECKS_FAILED=1
    fi
fi

#
# 4. Build check
#
print_header "Building"

if go build ./... 2>&1; then
    print_success "Build successful"
else
    print_error "Build failed"
    CHECKS_FAILED=1
fi

#
# 5. Run tests with coverage
#
print_header "Running Tests with Coverage"

# Run tests with coverage
TEST_OUTPUT=$(go test -short -timeout 120s -coverprofile=coverage.out ./... 2>&1)
TEST_EXIT_CODE=$?

if [ $TEST_EXIT_CODE -ne 0 ]; then
    if echo "$TEST_OUTPUT" | grep -q "FAIL"; then
        print_error "Tests failed"
        echo "$TEST_OUTPUT" | grep "FAIL"
        CHECKS_FAILED=1
    else
        print_success "Tests passed (some packages have no tests)"
    fi
else
    print_success "Tests passed"
fi

#
# 5b. Check coverage on changed files only
#
if [ -f coverage.out ]; then
    print_header "Checking Coverage on Changed Files"

    COVERAGE_THRESHOLD=80.0
    COVERAGE_FAILED=0
    COVERAGE_RESULTS=()

    # Check each staged Go file (excluding test files and entry points)
    for file in $STAGED_GO_FILES; do
        # Skip test files
        if [[ "$file" == *_test.go ]]; then
            continue
        fi

        # Skip cmd entry points (main.go files are hard to test)
        if [[ "$file" == cmd/main.go ]] || [[ "$file" == cmd/*/main.go ]] || [[ "$file" == ee/cmd/*/main.go ]]; then
            continue
        fi

        # Skip cmd CLI setup files (Cobra command setup - minimal testable logic)
        if [[ "$file" == cmd/*/cmd.go ]] || [[ "$file" == ee/cmd/*/cmd.go ]]; then
            continue
        fi

        # Skip arena-worker (PromptKit arena engine integration, tested via E2E)
        if [[ "$file" == cmd/arena-worker/worker.go ]] || [[ "$file" == ee/cmd/arena-worker/worker.go ]]; then
            continue
        fi

        # Skip arena controllers (async goroutines, Redis integration, tested via E2E)
        if [[ "$file" == internal/controller/arena*.go ]] || [[ "$file" == ee/internal/controller/arena*.go ]]; then
            continue
        fi

        # Skip arena-dev-console server (WebSocket + PromptKit runtime integration, tested via E2E)
        if [[ "$file" == ee/cmd/arena-dev-console/server/* ]]; then
            continue
        fi

        # Skip internal/runtime (requires local PromptKit dependency, not published yet)
        if [[ "$file" == internal/runtime/* ]]; then
            continue
        fi

        # Skip generated files (kubebuilder)
        if [[ "$file" == *zz_generated*.go ]] || [[ "$file" == api/*/groupversion_info.go ]]; then
            continue
        fi

        # Skip generated protobuf files
        if [[ "$file" == *.pb.go ]] || [[ "$file" == *_grpc.pb.go ]]; then
            continue
        fi

        # Skip E2E test utilities
        if [[ "$file" == test/* ]]; then
            continue
        fi

        # Skip internal/api/server.go (logs endpoint requires real K8s clientset for integration testing)
        if [[ "$file" == "internal/api/server.go" ]]; then
            continue
        fi

        # Skip internal/facade/metrics.go (NoOpMetrics has intentionally empty methods - null object pattern)
        if [[ "$file" == "internal/facade/metrics.go" ]]; then
            continue
        fi

        # Skip cloud storage implementations (require external infrastructure: S3/MinIO, GCS emulator, Azurite)
        if [[ "$file" == "internal/media/s3.go" ]] || [[ "$file" == "internal/media/gcs.go" ]] || [[ "$file" == "internal/media/azure.go" ]] || [[ "$file" == "internal/media/handler.go" ]]; then
            continue
        fi

        # Skip Redis session store (requires real Redis, tested in integration)
        if [[ "$file" == "internal/session/redis.go" ]]; then
            continue
        fi

        # Skip Postgres session store (requires real Postgres via testcontainers, tested in integration)
        if [[ "$file" == "internal/session/postgres/migrator.go" ]] || [[ "$file" == internal/session/providers/postgres/*.go ]]; then
            continue
        fi

        # Skip cold archive cloud blob store implementations (require external infrastructure: S3/MinIO, GCS, Azure)
        if [[ "$file" == internal/session/providers/cold/blobstore_s3.go ]] || [[ "$file" == internal/session/providers/cold/blobstore_gcs.go ]] || [[ "$file" == internal/session/providers/cold/blobstore_azure.go ]]; then
            continue
        fi

        # Calculate ACTUAL statement coverage from raw coverage.out
        # Format: file:startLine.startCol,endLine.endCol numStatements count
        # count > 0 means covered, count = 0 means not covered
        FILE_COV_PERCENT=$(grep "/$file:" coverage.out 2>/dev/null | awk -F'[ ]' '
        {
            # Last two fields: numStatements count
            # Split on space, get the numeric fields
            n = split($0, parts, " ")
            if (n >= 2) {
                count = parts[n]      # coverage count (0 = not covered, 1+ = covered)
                stmts = parts[n-1]    # number of statements in this block
                if (stmts ~ /^[0-9]+$/ && count ~ /^[0-9]+$/) {
                    total_stmts += stmts
                    if (count > 0) {
                        covered_stmts += stmts
                    }
                }
            }
        }
        END {
            if (total_stmts > 0) {
                printf "%.1f", (covered_stmts / total_stmts) * 100
            }
        }')

        if [ -n "$FILE_COV_PERCENT" ]; then
            # Check if coverage meets threshold
            COV_OK=$(echo "$FILE_COV_PERCENT $COVERAGE_THRESHOLD" | awk '{if ($1 >= $2) print "1"; else print "0"}')

            if [ "$COV_OK" = "1" ]; then
                COVERAGE_RESULTS+=("✓ $file: ${FILE_COV_PERCENT}%")
            else
                COVERAGE_RESULTS+=("✗ $file: ${FILE_COV_PERCENT}% (below ${COVERAGE_THRESHOLD}%)")
                COVERAGE_FAILED=1
            fi
        else
            # No coverage data for this file - check if it has any executable code
            # Files with only type definitions won't have coverage data
            HAS_FUNCS=$(grep -l "^func " "$REPO_ROOT/$file" 2>/dev/null || true)
            if [ -n "$HAS_FUNCS" ]; then
                COVERAGE_RESULTS+=("✗ $file: 0.0% (no coverage data)")
                COVERAGE_FAILED=1
            else
                COVERAGE_RESULTS+=("○ $file: N/A (no executable code)")
            fi
        fi
    done

    # Print results
    if [ ${#COVERAGE_RESULTS[@]} -eq 0 ]; then
        print_info "No non-test Go files to check (all changes in test/cmd files)"
    else
        for result in "${COVERAGE_RESULTS[@]}"; do
            echo "  $result"
        done

        echo ""
        if [ $COVERAGE_FAILED -eq 1 ]; then
            print_error "Some files have insufficient test coverage (threshold: ${COVERAGE_THRESHOLD}%)"
            print_info "Add tests for the uncovered code"
            CHECKS_FAILED=1
        else
            print_success "All changed files meet coverage threshold (≥${COVERAGE_THRESHOLD}%)"
        fi
    fi

    # Show overall summary
    echo ""
    TOTAL_COVERAGE=$(go tool cover -func=coverage.out | tail -1 | grep -oE '[0-9]+\.[0-9]+%')
    print_info "Overall project coverage: $TOTAL_COVERAGE"

    rm -f coverage.out
fi

#
# 6. Generate manifests check (kubebuilder specific)
#
print_header "Checking Generated Code"

# Run Go codegen (manifests + DeepCopy)
# Note: controller-gen doesn't work with go.work, so we disable it for codegen
GOWORK=off make generate manifests 2>/dev/null

GO_CHANGES=$(git diff --name-only config/ api/ 2>/dev/null || true)
if [ -n "$GO_CHANGES" ]; then
    print_error "Generated Go files are out of date:"
    for file in $GO_CHANGES; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make generate manifests' and commit the changes"
    CHECKS_FAILED=1
else
    print_success "Go manifests are up to date"
fi

# Sync CRDs to Helm chart
GOWORK=off make sync-chart-crds 2>/dev/null

HELM_CHANGES=$(git diff --name-only charts/omnia/crds/ 2>/dev/null || true)
if [ -n "$HELM_CHANGES" ]; then
    print_error "Helm chart CRDs are out of date:"
    for file in $HELM_CHANGES; do
        echo "  - $file"
    done
    echo ""
    print_info "Run 'make sync-chart-crds' and commit the changes"
    CHECKS_FAILED=1
else
    print_success "Helm chart CRDs are up to date"
fi

# Check dashboard types if dashboard files were changed or CRDs changed
if [ -n "$STAGED_DASHBOARD_FILES" ] || [ -n "$GO_CHANGES" ]; then
    # Generate TypeScript types from CRDs
    if command -v node &> /dev/null && [ -d "$REPO_ROOT/dashboard/node_modules" ]; then
        GOWORK=off make generate-dashboard-types 2>/dev/null

        TS_TYPE_CHANGES=$(git diff --name-only dashboard/src/types/generated/ 2>/dev/null || true)
        if [ -n "$TS_TYPE_CHANGES" ]; then
            print_error "Dashboard TypeScript types are out of date:"
            for file in $TS_TYPE_CHANGES; do
                echo "  - $file"
            done
            echo ""
            print_info "Run 'make generate-dashboard-types' and commit the changes"
            CHECKS_FAILED=1
        else
            print_success "Dashboard TypeScript types are up to date"
        fi
    fi
fi

#
# 7. Helm template validation (if chart files changed)
#
STAGED_HELM_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '^charts/' || true)
if [ -n "$STAGED_HELM_FILES" ]; then
    print_header "Validating Helm Templates"

    if "$REPO_ROOT/hack/validate-helm.sh" 2>&1; then
        print_success "Helm validation passed"
    else
        print_error "Helm validation failed"
        CHECKS_FAILED=1
    fi
fi

#
# Summary
#
print_header "Summary"

if [ $CHECKS_FAILED -eq 0 ]; then
    print_success "All pre-commit checks passed!"
    echo ""
    print_info "Proceeding with commit..."
    exit 0
else
    echo ""
    print_error "Pre-commit checks failed!"
    echo ""
    print_info "Options:"
    echo "  1. Fix the issues above and try again"
    echo "  2. Run 'make test' to see detailed test output"
    echo "  3. Use [skip-pre-commit] in commit message to bypass (not recommended)"
    echo ""
    exit 1
fi
