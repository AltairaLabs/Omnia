// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.0
// source: runtime/v1/runtime.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

/** ClientMessage represents a message from the client to the runtime. */
export interface ClientMessage {
  /** session_id identifies the conversation session for state management. */
  sessionId: string;
  /**
   * content is the user's message text (legacy, for backward compatibility).
   * For multimodal messages, use the parts field instead.
   */
  content: string;
  /** metadata contains optional key-value pairs for additional context. */
  metadata: { [key: string]: string };
  /**
   * parts contains multimodal content parts (text, images, audio, video, files).
   * If non-empty, this takes precedence over the content field.
   */
  parts: ContentPart[];
}

export interface ClientMessage_MetadataEntry {
  key: string;
  value: string;
}

/**
 * ServerMessage represents a message from the runtime to the client.
 * Uses oneof to ensure only one message type is sent at a time.
 */
export interface ServerMessage {
  message?:
    | //
    /** chunk contains a partial text response for streaming. */
    { $case: "chunk"; chunk: Chunk }
    | //
    /**
     * tool_call is informational, indicating a tool is being invoked.
     * The client/facade can display "Calling weather API..." but actual
     * tool execution happens entirely in the runtime.
     */
    { $case: "toolCall"; toolCall: ToolCall }
    | //
    /**
     * tool_result is informational, containing the result of a tool call.
     * This allows the UI to display tool results to the user.
     */
    { $case: "toolResult"; toolResult: ToolResult }
    | //
    /** done signals the completion of a response. */
    { $case: "done"; done: Done }
    | //
    /** error indicates an error occurred during processing. */
    { $case: "error"; error: Error }
    | undefined;
}

/** Chunk contains a partial text response for streaming output. */
export interface Chunk {
  /** content is the text chunk to append to the response. */
  content: string;
}

/** ToolCall represents a tool invocation (informational for UI display). */
export interface ToolCall {
  /** id is a unique identifier for this tool call. */
  id: string;
  /** name is the name of the tool being called. */
  name: string;
  /** arguments_json contains the tool arguments as a JSON string. */
  argumentsJson: string;
}

/** ToolResult contains the result of a tool execution (informational for UI display). */
export interface ToolResult {
  /** id matches the corresponding ToolCall id. */
  id: string;
  /** result_json contains the tool result as a JSON string. */
  resultJson: string;
  /** is_error indicates whether the tool execution failed. */
  isError: boolean;
}

/** Done signals the completion of a conversation turn. */
export interface Done {
  /**
   * final_content contains the complete response text (optional).
   * For text-only responses, this contains the full response.
   * For multimodal responses, use the parts field instead.
   */
  finalContent: string;
  /** usage contains token usage statistics for this turn. */
  usage?:
    | Usage
    | undefined;
  /**
   * parts contains multimodal content parts (text, images, audio, video).
   * If non-empty, this takes precedence over final_content for rich responses.
   */
  parts: ContentPart[];
}

/** ContentPart represents a single piece of content in a multimodal message. */
export interface ContentPart {
  /** type indicates the content type: "text", "image", "audio", "video" */
  type: string;
  /** text contains text content (only set when type="text") */
  text: string;
  /** media contains media content (only set when type="image", "audio", or "video") */
  media?: MediaContent | undefined;
}

/** MediaContent represents media data (image, audio, video) in a message. */
export interface MediaContent {
  /** data contains base64-encoded media data (for resolved file:// and mock:// URLs) */
  data: string;
  /** url contains the media URL (for http:// and https:// URLs that are passed through) */
  url: string;
  /** mime_type indicates the media format (e.g., "image/png", "audio/mp3") */
  mimeType: string;
}

/** Usage contains token usage and cost information. */
export interface Usage {
  /** input_tokens is the number of tokens in the input/prompt. */
  inputTokens: number;
  /** output_tokens is the number of tokens in the output/response. */
  outputTokens: number;
  /** cost_usd is the estimated cost in USD for this request. */
  costUsd: number;
}

/** Error represents an error that occurred during processing. */
export interface Error {
  /** code is a machine-readable error code. */
  code: string;
  /** message is a human-readable error description. */
  message: string;
}

/** HealthRequest is an empty message for health checks. */
export interface HealthRequest {
}

/** HealthResponse contains the health status of the runtime. */
export interface HealthResponse {
  /** healthy indicates whether the runtime is ready to handle requests. */
  healthy: boolean;
  /** status provides additional status information. */
  status: string;
}

function createBaseClientMessage(): ClientMessage {
  return { sessionId: "", content: "", metadata: {}, parts: [] };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      ClientMessage_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.parts) {
      ContentPart.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClientMessage_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parts.push(ContentPart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      sessionId: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => ContentPart.fromJSON(e)) : [],
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.session_id = message.sessionId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => ContentPart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.sessionId = object.sessionId ?? "";
    message.content = object.content ?? "";
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.parts = object.parts?.map((e) => ContentPart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClientMessage_MetadataEntry(): ClientMessage_MetadataEntry {
  return { key: "", value: "" };
}

export const ClientMessage_MetadataEntry: MessageFns<ClientMessage_MetadataEntry> = {
  encode(message: ClientMessage_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ClientMessage_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage_MetadataEntry>, I>>(base?: I): ClientMessage_MetadataEntry {
    return ClientMessage_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage_MetadataEntry>, I>>(object: I): ClientMessage_MetadataEntry {
    const message = createBaseClientMessage_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return { message: undefined };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "chunk":
        Chunk.encode(message.message.chunk, writer.uint32(10).fork()).join();
        break;
      case "toolCall":
        ToolCall.encode(message.message.toolCall, writer.uint32(18).fork()).join();
        break;
      case "toolResult":
        ToolResult.encode(message.message.toolResult, writer.uint32(26).fork()).join();
        break;
      case "done":
        Done.encode(message.message.done, writer.uint32(34).fork()).join();
        break;
      case "error":
        Error.encode(message.message.error, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "chunk", chunk: Chunk.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = { $case: "toolCall", toolCall: ToolCall.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = { $case: "toolResult", toolResult: ToolResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "done", done: Done.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = { $case: "error", error: Error.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      message: isSet(object.chunk)
        ? { $case: "chunk", chunk: Chunk.fromJSON(object.chunk) }
        : isSet(object.tool_call)
        ? { $case: "toolCall", toolCall: ToolCall.fromJSON(object.tool_call) }
        : isSet(object.tool_result)
        ? { $case: "toolResult", toolResult: ToolResult.fromJSON(object.tool_result) }
        : isSet(object.done)
        ? { $case: "done", done: Done.fromJSON(object.done) }
        : isSet(object.error)
        ? { $case: "error", error: Error.fromJSON(object.error) }
        : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.message?.$case === "chunk") {
      obj.chunk = Chunk.toJSON(message.message.chunk);
    } else if (message.message?.$case === "toolCall") {
      obj.tool_call = ToolCall.toJSON(message.message.toolCall);
    } else if (message.message?.$case === "toolResult") {
      obj.tool_result = ToolResult.toJSON(message.message.toolResult);
    } else if (message.message?.$case === "done") {
      obj.done = Done.toJSON(message.message.done);
    } else if (message.message?.$case === "error") {
      obj.error = Error.toJSON(message.message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    switch (object.message?.$case) {
      case "chunk": {
        if (object.message?.chunk !== undefined && object.message?.chunk !== null) {
          message.message = { $case: "chunk", chunk: Chunk.fromPartial(object.message.chunk) };
        }
        break;
      }
      case "toolCall": {
        if (object.message?.toolCall !== undefined && object.message?.toolCall !== null) {
          message.message = { $case: "toolCall", toolCall: ToolCall.fromPartial(object.message.toolCall) };
        }
        break;
      }
      case "toolResult": {
        if (object.message?.toolResult !== undefined && object.message?.toolResult !== null) {
          message.message = { $case: "toolResult", toolResult: ToolResult.fromPartial(object.message.toolResult) };
        }
        break;
      }
      case "done": {
        if (object.message?.done !== undefined && object.message?.done !== null) {
          message.message = { $case: "done", done: Done.fromPartial(object.message.done) };
        }
        break;
      }
      case "error": {
        if (object.message?.error !== undefined && object.message?.error !== null) {
          message.message = { $case: "error", error: Error.fromPartial(object.message.error) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseChunk(): Chunk {
  return { content: "" };
}

export const Chunk: MessageFns<Chunk> = {
  encode(message: Chunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chunk {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: Chunk): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chunk>, I>>(base?: I): Chunk {
    return Chunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chunk>, I>>(object: I): Chunk {
    const message = createBaseChunk();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { id: "", name: "", argumentsJson: "" };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.argumentsJson !== "") {
      writer.uint32(26).string(message.argumentsJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.argumentsJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      argumentsJson: isSet(object.arguments_json) ? globalThis.String(object.arguments_json) : "",
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.argumentsJson !== "") {
      obj.arguments_json = message.argumentsJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.argumentsJson = object.argumentsJson ?? "";
    return message;
  },
};

function createBaseToolResult(): ToolResult {
  return { id: "", resultJson: "", isError: false };
}

export const ToolResult: MessageFns<ToolResult> = {
  encode(message: ToolResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.resultJson !== "") {
      writer.uint32(18).string(message.resultJson);
    }
    if (message.isError !== false) {
      writer.uint32(24).bool(message.isError);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resultJson = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isError = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      resultJson: isSet(object.result_json) ? globalThis.String(object.result_json) : "",
      isError: isSet(object.is_error) ? globalThis.Boolean(object.is_error) : false,
    };
  },

  toJSON(message: ToolResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.resultJson !== "") {
      obj.result_json = message.resultJson;
    }
    if (message.isError !== false) {
      obj.is_error = message.isError;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolResult>, I>>(base?: I): ToolResult {
    return ToolResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolResult>, I>>(object: I): ToolResult {
    const message = createBaseToolResult();
    message.id = object.id ?? "";
    message.resultJson = object.resultJson ?? "";
    message.isError = object.isError ?? false;
    return message;
  },
};

function createBaseDone(): Done {
  return { finalContent: "", usage: undefined, parts: [] };
}

export const Done: MessageFns<Done> = {
  encode(message: Done, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalContent !== "") {
      writer.uint32(10).string(message.finalContent);
    }
    if (message.usage !== undefined) {
      Usage.encode(message.usage, writer.uint32(18).fork()).join();
    }
    for (const v of message.parts) {
      ContentPart.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Done {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalContent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usage = Usage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parts.push(ContentPart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Done {
    return {
      finalContent: isSet(object.final_content) ? globalThis.String(object.final_content) : "",
      usage: isSet(object.usage) ? Usage.fromJSON(object.usage) : undefined,
      parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => ContentPart.fromJSON(e)) : [],
    };
  },

  toJSON(message: Done): unknown {
    const obj: any = {};
    if (message.finalContent !== "") {
      obj.final_content = message.finalContent;
    }
    if (message.usage !== undefined) {
      obj.usage = Usage.toJSON(message.usage);
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => ContentPart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Done>, I>>(base?: I): Done {
    return Done.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Done>, I>>(object: I): Done {
    const message = createBaseDone();
    message.finalContent = object.finalContent ?? "";
    message.usage = (object.usage !== undefined && object.usage !== null) ? Usage.fromPartial(object.usage) : undefined;
    message.parts = object.parts?.map((e) => ContentPart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContentPart(): ContentPart {
  return { type: "", text: "", media: undefined };
}

export const ContentPart: MessageFns<ContentPart> = {
  encode(message: ContentPart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.media !== undefined) {
      MediaContent.encode(message.media, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentPart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentPart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.media = MediaContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentPart {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      media: isSet(object.media) ? MediaContent.fromJSON(object.media) : undefined,
    };
  },

  toJSON(message: ContentPart): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.media !== undefined) {
      obj.media = MediaContent.toJSON(message.media);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentPart>, I>>(base?: I): ContentPart {
    return ContentPart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentPart>, I>>(object: I): ContentPart {
    const message = createBaseContentPart();
    message.type = object.type ?? "";
    message.text = object.text ?? "";
    message.media = (object.media !== undefined && object.media !== null)
      ? MediaContent.fromPartial(object.media)
      : undefined;
    return message;
  },
};

function createBaseMediaContent(): MediaContent {
  return { data: "", url: "", mimeType: "" };
}

export const MediaContent: MessageFns<MediaContent> = {
  encode(message: MediaContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaContent {
    return {
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      mimeType: isSet(object.mime_type) ? globalThis.String(object.mime_type) : "",
    };
  },

  toJSON(message: MediaContent): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.mimeType !== "") {
      obj.mime_type = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaContent>, I>>(base?: I): MediaContent {
    return MediaContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaContent>, I>>(object: I): MediaContent {
    const message = createBaseMediaContent();
    message.data = object.data ?? "";
    message.url = object.url ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseUsage(): Usage {
  return { inputTokens: 0, outputTokens: 0, costUsd: 0 };
}

export const Usage: MessageFns<Usage> = {
  encode(message: Usage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputTokens !== 0) {
      writer.uint32(8).int32(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      writer.uint32(16).int32(message.outputTokens);
    }
    if (message.costUsd !== 0) {
      writer.uint32(29).float(message.costUsd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Usage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inputTokens = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.costUsd = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Usage {
    return {
      inputTokens: isSet(object.input_tokens) ? globalThis.Number(object.input_tokens) : 0,
      outputTokens: isSet(object.output_tokens) ? globalThis.Number(object.output_tokens) : 0,
      costUsd: isSet(object.cost_usd) ? globalThis.Number(object.cost_usd) : 0,
    };
  },

  toJSON(message: Usage): unknown {
    const obj: any = {};
    if (message.inputTokens !== 0) {
      obj.input_tokens = Math.round(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      obj.output_tokens = Math.round(message.outputTokens);
    }
    if (message.costUsd !== 0) {
      obj.cost_usd = message.costUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Usage>, I>>(base?: I): Usage {
    return Usage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Usage>, I>>(object: I): Usage {
    const message = createBaseUsage();
    message.inputTokens = object.inputTokens ?? 0;
    message.outputTokens = object.outputTokens ?? 0;
    message.costUsd = object.costUsd ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { code: "", message: "" };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest: MessageFns<HealthRequest> = {
  encode(_: HealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { healthy: false, status: "" };
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(message: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.healthy = object.healthy ?? false;
    message.status = object.status ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
