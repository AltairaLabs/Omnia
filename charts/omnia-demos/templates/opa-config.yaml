{{- if .Values.opa.enabled }}
---
# OPA Configuration ConfigMap
# Contains Rego policy for Ollama model validation
apiVersion: v1
kind: ConfigMap
metadata:
  name: ollama-opa-config
  namespace: {{ .Values.namespace }}
  labels:
    app.kubernetes.io/name: ollama-opa
    app.kubernetes.io/part-of: {{ include "omnia-demos.name" . }}
data:
  # Rego policy for model validation
  policy.rego: |
    package envoy.authz

    import rego.v1

    default allow := false

    # Allowed models from Helm values (primary + additional)
    allowed_models := {{ append .Values.ollama.additionalModels .Values.ollama.model | toJson }}

    # Helper to check if path requires model validation
    requires_model_validation if {
      input.attributes.request.http.path in ["/api/generate", "/api/chat", "/api/embeddings"]
    }

    # Helper to check if this is a model pull request
    is_pull_request if {
      input.attributes.request.http.path == "/api/pull"
    }

    # Raw request body
    raw_body := input.attributes.request.http.body

    # Try to parse JSON body from request (may fail for large bodies with images)
    parsed_body := json.unmarshal(raw_body)

    # Get requested model from parsed body
    requested_model := parsed_body.model if {
      parsed_body.model
    }

    # Get model name from pull request
    pull_model_name := parsed_body.name if {
      parsed_body.name
    }

    # Fallback: check if any allowed model appears in raw body (for large requests)
    raw_body_contains_allowed_model if {
      some allowed in allowed_models
      contains(raw_body, concat("", ["\"model\":\"", allowed, "\""]))
    }

    # Model matching - exact match
    model_matches_single(requested, allowed) if {
      requested == allowed
    }

    # Model matching - requested without tag, allowed with tag
    model_matches_single(requested, allowed) if {
      not contains(requested, ":")
      startswith(allowed, concat("", [requested, ":"]))
    }

    # Model matching - allowed without tag, requested with tag
    model_matches_single(requested, allowed) if {
      not contains(allowed, ":")
      startswith(requested, concat("", [allowed, ":"]))
    }

    # Check if requested model matches any allowed model
    model_matches(requested) if {
      some allowed in allowed_models
      model_matches_single(requested, allowed)
    }

    # Allow non-model endpoints (health, tags, version, etc.)
    allow if {
      not requires_model_validation
      not is_pull_request
    }

    # Allow if model matches any allowed model (parsed body)
    allow if {
      requires_model_validation
      model_matches(requested_model)
    }

    # Allow if raw body contains allowed model (fallback for large requests with images)
    allow if {
      requires_model_validation
      not requested_model
      raw_body_contains_allowed_model
    }

    # Allow pull requests only for allowed models
    allow if {
      is_pull_request
      model_matches(pull_model_name)
    }

    # Deny response with details
    deny_message := sprintf("Model '%s' not allowed. Permitted models: %v", [requested_model, allowed_models]) if {
      requires_model_validation
      requested_model
    }

    deny_message := sprintf("Cannot pull model '%s'. Permitted models: %v", [pull_model_name, allowed_models]) if {
      is_pull_request
      pull_model_name
    }

    deny_message := "Model validation failed: no model specified in request." if {
      requires_model_validation
      not requested_model
    }

    deny_message := "Model pull failed: no model name specified in request." if {
      is_pull_request
      not pull_model_name
    }

    # Default deny message
    default deny_message := "Request denied by policy."

    # Response headers for denied requests
    deny_headers := {"content-type": "application/json"}

    # Deny response body
    deny_body := json.marshal({
      "error": deny_message,
      "allowed_models": allowed_models
    })
{{- end }}
